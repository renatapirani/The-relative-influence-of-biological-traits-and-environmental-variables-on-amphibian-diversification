---
title: "ClaDS_script"
output: html_document
date: "2024-02-05"
---

######################################################################
2. ClaDS - model-based Bayesian approach
######################################################################

1. PANDA: Phylogenetic ANalyses of DiversificAtion
  - PANDA require julia command line installed (https://julialang.org/downloads/)
  - tutorial: (https://hmorlon.github.io/PANDA.jl/stable/clads/tutorial/)
  - Load the phylogeny from Jetz and Pyron (2018)
  
```{r}
## julia termnial run:
# julia> using PANDA
# julia> my_tree = load_tree("/Users/renatapirani/Documents/julia/Amph.final.tre") 
## use the ultrametric tree from the BAMM script - Amph.final.tre

## select the parameters and sampling fraction based on IUCN red list
# julia> output = infer_ClaDS(my_tree, 10000, print_state = 100, f = 0.83)
# julia> @save "/Users/renatapirani/Documents/julia/output.jld2" output # save the output
# julia> save_ClaDS_in_R(output2, "/Users/renatapirani/Documents/julia/output.Rdata")
```

2. Working in R with ClaDS output from julia command line.

```{r}
## output from ClaDS
setwd("/Users/renatapirani/Documents/UCLA/Project/Speciation_Rate/analyses_R/ClaDS/")

## load the ClaDS output
load("output.Rdata")

## the lambdai_map is the speciation rates for each species
CladsOutput$lambdatip_map
```

2.Get the tip rates for each species using ClaDS to be able to run PGLS

```{r}
# the function returns a list with the tree and the associated rates. Here is how you get to them :
Frog_tree = CladsOutput$tree
speciation_rates = CladsOutput$lambdatip_map


# and the plotting function
plot.with.rate(Frog_tree,speciation_rates,
               log=T,        # should the rates be plotted on a log scale?
               lwd=3)        # width of the branches
```

3. Function to make ClaDS a BAMM object by script from Singhal et al. 2018.

```{r}
# assignSpanningSet
# Find spanning taxon pairs for each node,
#    required to create event data object

assignSpanningSet <- function(phy, slow = FALSE){
  
  nodeset <- character(max(phy$edge))
  nodeset[1:length(phy$tip.label)] <- phy$tip.label
  ntips <- length(phy$tip.label)
  rootnode <- ntips + 1
  
  spanmat <- matrix(NA, nrow=length(nodeset), ncol=2)
  spanmat[1:ntips,1] <- phy$tip.label
  
  if (slow){
    for (ii in rootnode:nrow(phy$edge)){
      xc <- extract.clade(phy, node = ii)$tip.label
      spanmat[ii,] <- xc[c(1, length(xc))]
    }
    
  }else{
    for (ii in 1:length(phy$tip.label)){
      tipname <- phy$tip.label[ii]
      curr_node <- ii
      DONE <- FALSE
      while (curr_node != rootnode & !DONE){
        anc <- phy$edge[,1][phy$edge[ , 2] == curr_node]
        if (nodeset[anc] == ""){
          nodeset[anc] <- tipname
          curr_node <- anc
        }else{
          DONE <- TRUE
        } 
      }
    }		
    for (ii in rootnode:max(phy$edge)){
      dset <- nodeset[phy$edge[,2][phy$edge[,1] == ii]]
      spanmat[ii, ] <- dset
    }
    
  }
  
  return(spanmat)
  
}

# clads_to_eventdata
#	args:
#	map_clads: clads output object w stored MAP rates (as provided)
#   delta: must be smaller than the smallest branch length in tree
#   Tree must be fully resolved; no zero length branches.

clads_to_eventdata <- function(map_clads, delta = 0.00001){
  
  tree <- as.phylo(map_clads$tree)
  tree <- check_and_fix_ultrametric(tree)
  
  phy <- BAMMtools:::getStartStopTimes(tree)
  
  spanmat <- assignSpanningSet(phy)
  
  generation <- rep(1, nrow(spanmat))
  leftchild  <- spanmat[,1]
  rightchild <- spanmat[,2]
  
  abstime     <- numeric(nrow(spanmat))
  lambdainit  <- numeric(nrow(spanmat)) 
  lambdashift <- numeric(nrow(spanmat))
  muinit      <- numeric(nrow(spanmat))
  mushift     <- numeric(nrow(spanmat))
  
  # iterate over nodes, 
  #   fill in rates times etc
  for (ii in 1:nrow(phy$edge)){
    fnode <- phy$edge[ii,2]
    lambdainit[fnode] <- map_clads$lambdai_map[ii]
    abstime[fnode]    <- phy$begin[ii] + delta
  }
  
  # The root process is still not filled in;
  #   just take mean rate for 2 desc branches:
  rootnode <- length(phy$tip.label) + 1
  root_rates <- map_clads$lambdai_map[phy$edge[,1] == rootnode]
  lambdainit[rootnode] <- mean(root_rates)
  if (length(map_clads$eps_map == 1)){
    muinit <- map_clads$eps_map * lambdainit
  }else{
    stop("branch-specific epsilon currently not supported\n")
  }
  
  dff <- data.frame(generation, leftchild, rightchild, abstime, lambdainit, lambdashift, muinit, mushift, stringsAsFactors=F)
  
  dff <- dff[order(dff$abstime), ]
  
  phy <- read.tree(text = write.tree(ladderize(tree)))
  
  ed <- getEventData(phy, eventdata = dff, burnin=0, nsamples=1)
  return(ed)
}

# check_and_fix_ultrametric
#     checks trees to see if they pass ape ultrametricity test.
# If not, it computes the differential root-to-tip distance across all tips.
# It adds the appropriate quantity to each terminal branch length to ensure that 
# tree passes ultrametric test.
# Note: this is only a valid method of making trees ultrametric when the 
# 	non-ultrametricity is due to small numerical discrepancies, e.g., 
#   rounding or other floating point issues during phylogeny construction.
# 

check_and_fix_ultrametric <- function(phy){
  
  if (!is.ultrametric(phy)){
    
    vv <- vcv.phylo(phy)
    dx <- diag(vv)
    mxx <- max(dx) - dx
    for (i in 1:length(mxx)){
      phy$edge.length[phy$edge[,2] == i] <- phy$edge.length[phy$edge[,2] == i] + mxx[i]
    }
    if (!is.ultrametric(phy)){
      stop("Ultrametric fix failed\n")
    }	
  }
  
  return(phy)
}
```

4. Making my ClaDS output into BAMM obj

```{r}
ClaDS_data <- clads_to_eventdata(CladsOutput, delta = 0.00001)
## mean speciation rate for the data and estimate the 90% highest posterior density 
mean(ClaDS_data$meanTipLambda) # = 0.06730746, low speciation
quantile(ClaDS_data$meanTipLambda, c(0.05, 0.95))
```

5. Plot tree

```{r}
plot.bammdata(ClaDS_data, lwd=c(0.5,0.5), method="polar", pal="temperature", legend = T, breaksmethod='jenks')
```

6. Get the tip rates using ClaDS as BAMM obj to be able to run PGLS 

```{r}
CLmeanlam <- getTipRates(ClaDS_data, returnNetDiv = FALSE,
                       statistic = 'mean')$lambda.avg
CLmeanlam

# Create a vector of values for the meanlam values from BAMM
CL_meanlam <- data.frame(lambda_ClaDS = CLmeanlam)

# Duplicate the index column so you have a new column named tiplabel
CL_meanlam$tiplabel <- rownames(CL_meanlam)
```





